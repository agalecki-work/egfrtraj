% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_egfrtibble.R
\name{extract_egfrtibble}
\alias{extract_egfrtibble}
\title{Extract and standardize eGFR tibble for analysis}
\usage{
extract_egfrtibble(
  data,
  key_vars = list(id_col = "id", time_col = "time", egfr_col = "egfr"),
  filter = NULL,
  ...
)
}
\arguments{
\item{data}{A data frame or tibble containing longitudinal eGFR data}

\item{key_vars}{A named list specifying the column names for the key variables.
Default: \code{list(id_col = "id", time_col = "time", egfr_col = "egfr")}}

\item{filter}{A function that takes a data frame as first argument and returns
a logical vector (rows to keep).
If \code{NULL} (default), keeps subjects with at least 5 non-missing \code{egfr} values.}

\item{...}{Additional arguments passed to the \code{filter} function}
}
\value{
An \code{"egfrtibble"} object (tibble subclass) with columns \code{id}, \code{time}, \code{egfr}
and attribute \code{origdata_info} containing metadata about the input data.
}
\description{
Prepares a clean tibble with standardized column names (\code{id}, \code{time}, \code{egfr})
from a longitudinal dataset. First removes rows with missing values in the key
columns, then applies user-specified or default filtering.

The returned object has class \code{"egfrtibble"} (inherits from tibble) and carries
metadata about the original data as an attribute (\code{origdata_info}), including
a \code{final_subjects} field that can be used for dispatch (\code{"one"} or \code{"All"}).
}
\examples{
\dontrun{
# ── Basic usage (default column names and default filter) ────────────────────
res <- extract_egfrtibble(example_egfr_data)

# Quick inspection
class(res)                                 # "egfrtibble" + tibble classes
dim(res)                                   # rows × 3 (id, time, egfr)
attr(res, "origdata_info")$final_subjects  # usually "All"


# ── Long / explicit form using key_vars argument ─────────────────────────────
# (useful when column names differ from defaults or for clarity)
res_explicit <- extract_egfrtibble(
  data = example_egfr_data,
  key_vars = list(
    id_col   = "id",           # original column name for subject identifier
    time_col = "time",         # original column name for time/visit
    egfr_col = "egfr"          # original column name for eGFR values
  )
)

# The result should be identical to res when column names match defaults
identical(res, res_explicit)


# ── Single-subject example ───────────────────────────────────────────────────
# Extract data for just one subject first
one_id <- unique(example_egfr_data$id)[1]
one_subject_data <- example_egfr_data[example_egfr_data$id == one_id, ]

res_one <- extract_egfrtibble(one_subject_data)
attr(res_one, "origdata_info")$final_subjects  # should be "one"


# ── Custom filter: keep only subjects with max(egfr) ≥ 100 ───────────────────
res_high <- extract_egfrtibble(
  example_egfr_data,
  filter = function(d) {
    d |>
      dplyr::group_by(id) |>
      dplyr::summarise(max_e = max(egfr, na.rm = TRUE)) |>
      dplyr::mutate(keep = max_e >= 100) |>
      dplyr::right_join(d, by = "id") |>
      dplyr::pull(keep)
  }
)

# Check how many subjects remain
attr(res_high, "origdata_info")$n_subjects_final
attr(res_high, "origdata_info")$final_subjects


# ── Invalid input (caught early) ─────────────────────────────────────────────
# This will stop with a clear error message
# extract_egfrtibble(
#   example_egfr_data,
#   key_vars = list(id_col = "id", time_col = "id", egfr_col = "egfr")
# )
# → Error: Duplicate column names detected in key_vars: id
}
}
